#!/bin/bash

# Copyright (C) 2025 Pedro Alves.
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Restore a series of abandoned Gerrit changes.

# To restore all commits related to a given Gerrit change (with the
# --related option), we must use the REST interface, and for that, you
# must create a Gerrit HTTP password/token (not the regular login
# password) in the web interface.  See
# <https://gerrit-review.googlesource.com/Documentation/dev-rest-api.html#_authentication>.
# You can put the credentials in a the ~/.netrc file.  See "man curl".
#
# Restoring by Git commit does not require the REST interface, and so
# does not require a HTTP password/token.
#
# Curl supports proxying.  If you need it, set the
# http_proxy/https_proxy environment variables accordingly.

#!/bin/bash

set -euo pipefail

echoerr() { echo "$@" 1>&2; }

suggest_help() {
    echo "Try '$0 --help' for more information."
}

help() {
    cat <<EOF
Usage: $0 [OPTIONS] HOSTNAME REVISION

Restore a series of abandoned Gerrit changes by Gerrit change number
or Git revision (hash, branch name, tag) or .

Options:
  --ssh SSH_SERVER
         The gerrit server to connect to via SSH.
  --rest HTTP_SERVER
         The gerrit server to connect to via HTTP/HTTPS for REST API
         calls.
  --related CHANGE_NUM
         The Gerrit change number of one of the commits in a series of
         related changes.
  --hash GIT_REVISION
         The Git revision (hash, branch, etc.) of the top commit to
         restore.
  -c,--count COUNT
         Number of changes to restore starting at the given git hash
         (inclusive).  Defaults to 1.  Requires --hash.
  -n,--dry-run
         Print what would be done, but do not execute.
  --help
         Show this help message.

Examples:

  - Restore the 100 patches series whose top commit has Git hash abcdef1:

    $0 --dry-run --ssh gerritgit-server --rest https://gerrit.local --hash abcdef1 -c 100

  - Restore the series that contains the Gerrit change number 12345678:

    $0 --dry-run --ssh gerritgit-server --rest https://gerrit.local --related 12345678

  - Same, but use a HTTPS proxy server:

    https_proxy=http://proxy-server.local:8080 $0 --dry-run --ssh gerritgit-server --rest https://gerrit.local --related 12345678

EOF
}

DRY_RUN=false
NUM_PATCHES=1
CHANGE_NUM=
TOP_COMMIT=
SSH_SERVER=
REST_SERVER=

POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
	--ssh)
	    SSH_SERVER="$2"
	    shift
	    shift
	    ;;
	--rest)
	    REST_SERVER="$2"
	    shift
	    shift
	    ;;
	--related)
	    CHANGE_NUM="$2"
	    shift
	    shift
	    ;;
	--hash)
	    TOP_COMMIT="$2"
	    shift
	    shift
	    ;;
	-c|--count)
	    NUM_PATCHES="$2"
	    shift
	    shift
	    ;;
	-n|--dry-run)
	    DRY_RUN=true
	    shift
	    ;;
	--help)
	    help
	    exit 0
	    ;;
	-*)
	    echo "$0: unrecognized option '$1'" 1>&2
	    suggest_help 1>&2
	    exit 1
	    ;;
	*)
	    POSITIONAL_ARGS+=("$1")
	    shift
	    ;;
    esac
done

# Restore positional arguments.
set -- "${POSITIONAL_ARGS[@]}"

if [[ $# -ne 0 ]]; then
    echoerr "$0: Wrong number of arguments."
    suggest_help 1>&2
    exit 1
fi

SSH="ssh -x $SSH_SERVER"

restore() {
    STATUS="$1"
    SUBJECT="$2"
    URL="$3"

    if [[ "$STATUS" != "ABANDONED" ]]; then
	echo "‚úÖ $HASH is not abandoned (status=$STATUS), skipping."
	echo "    $URL"
	echo "    \"$SUBJECT\""
	return
    fi

    echo "‚ôªÔ∏è Restoring $HASH..."
    echo "    $URL"
    echo "    \"$SUBJECT\""

    cmd="$SSH gerrit review --restore $HASH"
    if $DRY_RUN; then
	echo "[dry-run] $cmd"
    else
	$cmd
    fi
}

if [ -z "$SSH_SERVER" ]; then
    echoerr "Must specify --ssh."
    exit 1
fi

if [ -z "$REST_SERVER" ]; then
    echoerr "Must specify --rest."
    exit 1
fi

if [ -z "$CHANGE_NUM" ] && [ -z "$TOP_COMMIT" ]; then
    echoerr "Must specify one of --related or --hash."
    exit 1
fi

if ! [ -z "$CHANGE_NUM" ]; then
    echo "üîç Restoring commits related to change #$CHANGE_NUM."

    # Call the REST API and strip the JSON anti-CSRF prefix.
    RESPONSE=$(curl -s --netrc "$REST_SERVER/a/changes/${CHANGE_NUM}/revisions/current/related" | sed '1d')

    if [[ -z "$RESPONSE" || "$RESPONSE" == "Not Found" ]]; then
	echo "‚ùå Error: change #$CHANGE_NUM not found in Gerrit."
	exit 1
    fi

    CHANGES=$(echo "$RESPONSE" | jq -c '.changes[]')

    COUNT=0
    while IFS= read -r entry; do
	STATUS=$(echo "$entry" | jq -r '.status')
	HASH=$(echo "$entry" | jq -r '.commit.commit')
	SUBJECT=$(echo "$entry" | jq -r '.commit.subject')
	CHANGE=$(echo "$entry" | jq -r '._change_number')
	URL="$REST_SERVER/c/${CHANGE}"

	restore "$STATUS" "$SUBJECT" "$URL"
	COUNT=$((COUNT + 1))
    done <<< "$CHANGES"

    echo "Found $COUNT related gerrit changes."
elif ! [ -z "$TOP_COMMIT" ]; then
    echo "üîç Extracting $NUM_PATCHES commits ending at $TOP_COMMIT."

    # Validate that the top commit exists.
    if ! git cat-file -e "$TOP_COMMIT" 2>/dev/null; then
	echoerr "‚ùå Error: Commit $TOP_COMMIT not found in the current Git repository."
	exit 1
    fi

    COMMITS=$(git log --reverse --format="%H" -n "$NUM_PATCHES" "$TOP_COMMIT")

    for HASH in $COMMITS; do
	# Check if the commit is abandoned in Gerrit.
	CHANGE_INFO=$($SSH gerrit query "$HASH" --format=JSON \
			  | jq -c 'select(has("status"))' \
			  | head -n 1)

	if [[ -z "$CHANGE_INFO" ]]; then
	    echoerr "‚ùå Error: Commit $TOP_COMMIT is not recognized by Gerrit (no associated change)."
	    exit 1
	fi

	STATUS=$(echo "$CHANGE_INFO" | jq -r '.status')
	SUBJECT=$(echo "$CHANGE_INFO" | jq -r '.subject')
	URL=$(echo "$CHANGE_INFO" | jq -r '.url')

	restore $STATUS $SUBJECT $URL
    done
else
    echoerr "One of --related or --hash must be given."
    exit 1
fi

